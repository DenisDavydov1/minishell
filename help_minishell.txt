

to do list:
1.  при запуске минишелла удалять значение переменной  old_pwd, при переходе записывать в нее предыдущий путь
2. export не должен добавлять переменную с цифрой в начале названия (bash: export: `7aa=asdf': not a valid identifier)
3. экспорт не должен добавлять если вокруг равно есть пробелы (bash: export: `=': not a valid identifier)
4. export export oooo=(rty rty w) делает запись: declare -ax oooo='([0]="rty" [1]="rty" [2]="w")'
5. export oooo=rty rty w делает три записи: declare -x oooo="rty", declare -x rty, declare -x w

6. cd ~, cd .., cd /

7.  cat "a b"
    cat: a b: No such file or directory

8.  echo n m
    n m
9. Получить PID процесса и отдавать его при echo $$
10. Обратный слэш экранирует специальные символы (echo \$$$ == echo $$)

11. Допустимые символы для переменной окружения: a-z, A-Z, _ и 0-9 (но не должна начинаться с цифры)
12. export a=5=6 работает: declare -x a="5=6"
13. export a= работает: declare -x a=""

14. cat a >> c >> b создает файл с и ничего в него не записывает, но дозаписывает содержимое а в файл c
	то же самое в cat a > c > b
15. < e < t > t

16. export a=& дает странный результат (если переменная "a" существует): [1] 46384
[1]+  Done                    export a=

17. export a=$ в команде env выглядит как a=$, а в команде export как declare -x a="\$"

18. Значение переменной окружения может содержать любой символ, но специальные символы <>&| и пробел
(возможно еще какие то символы) должны экранироваться обратным слэшем "\" либо браться в кавычки:
export a=4" "6 дает результат declare -x a="4 6"

перенаправления и пайпы по идее должны обрабатываться и как то работать в значениях переменных окружения 
bash-3.2$ export a=4&
[1] 46885
bash-3.2$ export a=&
[2] 46886
[1]   Done                    export a=4
bash-3.2$ export a=|
[2]+  Done                    export a=


> не должен перезаписывать файл полностью, а должен записать сначала файла


 # | Expression  | Result      | Comments
---+-------------+-------------+--------------------------------------------------------------------
 1 | "$a"        | apple       | variables are expanded inside ""
 2 | '$a'        | $a          | variables are not expanded inside ''
 3 | "'$a'"      | 'apple'     | '' has no special meaning inside ""
 4 | '"$a"'      | "$a"        | "" is treated literally inside ''
 5 | '\''        | **invalid** | can not escape a ' within ''; use "'" or $'\'' (ANSI-C quoting)
 6 | "red$arocks"| red         | $arocks does not expand $a; use ${a}rocks to preserve $a
 7 | "redapple$" | redapple$   | $ followed by no variable name evaluates to $
 8 | '\"'        | \"          | \ has no special meaning inside ''
 9 | "\'"        | \'          | \' is interpreted inside "" but has no significance for '
10 | "\""        | "           | \" is interpreted inside ""
11 | "*"         | *           | glob does not work inside "" or ''
12 | "\t\n"      | \t\n        | \t and \n have no special meaning inside "" or ''; use ANSI-C quoting
13 | "`echo hi`" | hi          | `` and $() are evaluated inside ""
14 | '`echo hi`' | `echo hi`   | `` and $() are not evaluated inside ''
15 | '${arr[0]}' | ${arr[0]}   | array access not possible inside ''
16 | "${arr[0]}" | apple       | array access works inside ""
17 | $'$a\''     | $a'         | single quotes can be escaped inside ANSI-C quoting
18 | "$'\t'"     | $'\t'       | ANSI-C quoting is not interpreted inside ""
19 | '!cmd'      | !cmd        | history expansion character '!' is ignored inside ''
20 | "!cmd"      | cmd args    | expands to the most recent command matching "cmd"
21 | $'!cmd'     | !cmd        | history expansion character '!' is ignored inside ANSI-C quotes
---+-------------+-------------+--------------------------------------------------------------------



QUOTES

MYVAR=sometext
echo "double quotes gives you $MYVAR"
echo 'single quotes gives you $MYVAR'

will give this:

double quotes gives you sometext
single quotes gives you $MYVAR



PIPES

echo a | cat -e < 2
эквивалентно 
echo a > aa
cat -e < aa < 2


Hidden variables
a=5
echo $a


> file 
должно создавать пустой файл либо делать пустым существующий

< file
не делает ничего

<> file
не делает ничего